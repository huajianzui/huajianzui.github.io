---
layout: post
title: JavaScript
date: 2020-12-20
Author: 念书
keyword: JavaScript
excerpt: JavaScript,ES6,ES7,ES8,ES9
categories: 
tags: [JavaScript]
comments: true
---

​	JavaScript作为前端的三驾马车之一,负责页面的行为(动作,交互,逻辑处理等),是一种面向对象的弱类型的解释型语言,可以视为人的经脉.

### 定义

95年诞生的js,在那个网速很慢的时代,js的出现,把一些需要到服务端处理的事情拿到浏览器中处理,缩短了用户的等待时间,增强了交互效果.特别是ajax出现后,局部刷新,动态加载使得JavaScript的地位变得炽手可热.Node的出现使得js在后端方面也占有了一席之地.

版本方面从一开始的网景公司和微软公司的竞争开始,到ECMA制定1.1规范,再到跳过版本4,把3.1转为版本5,再到2015年开始的ES2015,从此每年的6月出一版草案. 我们经常说的ES6就是对15年包括之后版本的统称.

我们把JavaScript 当做对ESMAScript规范的一种实现,实际上js除了核心的ESMAScipt外还要实现DOM和BOM.



JavaScript 

 1. 核心(ECMAScript)  |语法,语句,类型,操作符 

 2. 文档对象模型(DOM) |DOM是由W3C规定的标准,目前为DOM3,包括DOM核心,DOM HTML,DOM 视图,DOM事件,DOM样式,DOM遍历和范围,DOM保存,加载和验证.我们平常说的DOM树和DOM操作就指这部分

 3. 浏览器对象模型(BOM)  | 操作浏览器窗口,获取浏览器相关信息,像我们常用的location对象,screen对象,XMLHttpRequest对象,navigator对象,window对象.以及H5带来一些对象,H5的出现给BOM带来了标准的统一

    

### 分类

js相对来说没有啥分类,可以根据运行环境分为Node环境,浏览器环境,web worker也能算一种,也可以根据文档规范分为严格模式('use strict';)和非严格模式



### 核心

#### 1. 基础

```js
/****基本类型****/

//五种基本类型 Undefined,Null,Boolean,Number,String 一种引用类型Object
//其中Boolean,Number,String 还有对应的封装类型,在我们操作基本类型时,进行装箱和拆箱,所以我们可以用基本类型调用方法
var a;
typeof a; //"undefined"
//需要注意的是 变量不定义和不声明 typeof 都是undefined
a = true;
typeof a; //"boolean"
//boolean类型只有两个值 完全小写的  true 和 false
//其他类型也都可以转为boolean值,if语句就有自动转换的功能
//String 非""字符串都为true,Boolean("") false Boolean(" ") true
//Number 非零为true ; 0和NaN为false
//Object 任何对象为true   null为false
//undefined Boolean(undefined) false

a = 1;
typeof a; //"number"
typeof NaN;//"number"
//NaN 在IEEE754中指数部分全为1,小数非零的数值表示NaN
NaN == NaN; //false
//精度 IEEE754双精度浮点数规范,2进制不适合表示10进制小数
//范围 
Number.MAX_VALUE //1.7976931348623157e+308 
// 64位表示位  111 111 111 10    111 111 111 111 111 111 111 111 111 111 111 111 111 111 111 111 111 1  即 11位指数位和52位小数位 2**(2**11 - 1 -1023)*小数部分 = (2**53 - 1)*2**971
Number.POSITIVE_INFINITY//infinity
//向偶舍入
Number.MIN_VALUE //5e-324   在规约形式中的最接近0的数值并不是这个,这应该是非规约
Number.NEGATIVE_INFINITY//-infinity
a = "a";
typeof a; //"string"
//除null和undefined外任何类型都有一个toString()方法
//string中有转义字符例如\n,\unnn,这些字符在字符串中会被自动转化
//string一旦创建就不会改变,要改变一个字符要销毁原字符串再创建新的字符串
a = null;
typeof a; //"object" 这是需要注意的地方
a = {};
typeof a; //"object"
a = / /;
typeof a; //"object"

/****运算符****/ 

//一般的数值运算符会对非数值进行数值转换,像对象一般先调用valueOf方法,如果不行再调用toString方法
//负数是以它的绝对值的补码形式存在的,补码 = 反码 + 1 ;
//加法 
Infinity + -Infinity;//NaN
//如果有一个是字符串则把另一个转为字符串进行字符串拼接
//如果如果另一个是对象,数值或布尔则调用先调用valueOf(),toString进行字符串拼接
[] + {}; //"[object Object]" 
/*这里注意一下 {}+[]的值是0 ,因为{}在前边的时候变成了代码块而不是对象,同样的{}.toString()会报错,因为{}被当成了代码块 {}+[] 就变成了+[];可以加()变成表达式({}+[])*/
{} + {} // [object Object][object Object]
{}+{}; //+{} NaN
+null; 0
+undefined;//NaN
//减法相对简单只是进行数值转换,没有字符串拼接

//关系操作符 <  > <= >= == ===
//关系运算符 其中一个是数值则把另外一个转为数值,像"a"一般会转为NaN与数值比较都返回false
//比较特殊的是null +null==0,但是null!=0;null<=0;  比较时不能把null和undefined转化
//对象一般先调用valueOf()不行再调用toString() 然后再参与比较
//字符串比较是比较的字符编码ASCII大小
//boolean比较也是要先转为数值
//===符号只比较不转换
//三目运算符  a>b?a:b; 三目运算符的运算优先级极低使用时要注意

//值传递和引用传递
//主要就是在一下情况发生时,方法内的data修改与参数再无关系
function demo(data) {
    data = {}
}
```

#### 2.继承(原型链)

```js
//构造方法,首字母大写
function Fun(name,age,job){
    this.name=name;
    this.age=age;
    this.job=job;
}
var obj =new Fun('gkk','18',"软件开发"); //Fun {name: "gkk", age: "18", job: "软件开发"}
obj instanceof Fun //true
"age" in obj;//true
//这里强调一下如果构造函数有返回值,且返回值是对象,那么会覆盖掉生成的对象.
//构造函数的执行过程 创建对象,作用域给对象,执行构造函数,返回新对象
function Fun1(name,age,job){
    this.name=name;
    this.age=age;
    this.job=job;
    return {}
}
new Fun1('小明','18',"软件开发");//{}
//属性分为数值属性(Writable,Value)和访问器属性(Get,Set) 

/****原型****/
//任何函数都有一个prototype指向它的原型,用来所有实例共享相同的属性和方法,避免创建实例做一些重复的事情
obj.__proto__ == Fun.prototype;//true
Fun.prototype.constructor == Fun;//true
Fun.prototype.__proto__ == Object.prototype//true Fun的原型的原型等于Object的原型,
Fun.prototype.__proto__.constructor == Object//true
Fun.__proto__.constructor == Function //true
Object.__proto__.constructor == Function //true
Function.__proto__ == Function.prototype//Function上找还是自己
Object.prototype.__proto__;// null
Object.prototype.a = "a";
1..a;//a
1 .a;//a
"1".a


//原型链用于继承
FUN1.prototype = obj; //这样有一个问题,在原型上有引用类型时,更改一个child会影响father
//可以组合式继承 构造方法和原型一起用,更改原型的constructor为
function SuperType(name) {
    this.name = name;
    this.colors = ["red","blue","green"];
}
function SubType(name,age) {
    SuperType.call(this,name);
    this.age = age;
}
SubType.prototype = new SuperType(); //会执行两遍,不可取
SubType.prototype.constuctor = SubType;//后边可改
SubType.prototype = Object.create(SuperType.prototype,{
    constructor: {
        value: SubType,
        writeable: false 
    }
});
var staticKeys = Objevt.entries(SuperType); //静态属性
for(let [key,value] of staticKeys) { //挂载静态元素
    SubType[key] = value;
}
```

[![WswHBt.png](https://z3.ax1x.com/2021/07/23/WswHBt.png)](https://imgtu.com/i/WswHBt)

#### 3.作用域与this指向与闭包

```js
//js 在ES6之前没有块级作用域,只有全局和函数作用域
//提到作用域就不得不提一下变量的声明提升
console.log(a); //undefined
console.log(b); //b is not defined
var a = 1;
//方法声明的权重高于变量,但是执行时的变量赋值会覆盖方法
function a() {
    console.log("This is a function");
}
a(); //This is a function
var a = 1;
console.log(a);//1

//console.log(init); undefined 在块级作用域外中不会提升方法体,只会提升声明

{
   // init = 4; 如果先为变量则在外边是4
    function init() {
        
    }
    init = 4;
    console.log(init)//4
}

console.log(init); // function init(){} ,在块作用域外存在方法保护


//执行栈和作用域链
/*
执行环境定义了变量和函数有权访问的其他数据,每个执行环境中都有一个与之关联的变量对象(variable object)
函数的活动对象作为变量对象,arguments对象作为函数活动对象第一个变量
当一个函数创建时会预先创建一个包含全局变量对象的作用域链保存在函数内部的[[scope]]属性中(特指最外边的局部函数,如果是函数内部的函数则这个作用域链包含外部的函数)
当一个函数执行时,创建当前的执行环境,复制当前函数的[[scope]]中对象构建起当前执行环境的作用域链,把当前的活动对象(activation object)推入到作用域的前端,执行环境被推入到执行栈中,在函数中使用变量时,会沿着作用域链向查找
函数执行之后执行环境从栈中弹出
另外需要提一下 with,try catch,eavl,new Function
with和catch会延长作用域链,with添加指定对象,catch会创建新的对象到作用域链前端.
eavl和 new Function都会接受一段字符串然后转化为执行语句,
eavl内的执行环境是当前作用域与当前环境的作用域链相同,new Function执行环境是全局作用域
*/
/*this指向问题
常规来说this对象指向的函数运行时的执行环境,即哪个对象调用的方法this就指向哪个对象,匿名函数和全局函数,setTimeout的回调函数的作用对象是window(非严格模式,严格模式下方法内的this是undefined),需要注意的是函数名只是指向函数对象的指针,在赋值时候obj.funName 与 funName 没有什么不同
构造方法中的this指向实例
但是箭头函数不符合这个常规,箭头函数绑定的是定义的时候它外层的作用域,不会在执行时候改变
*/
var name = "outer";
var obj = {
    name:"inner",
    print: function() {
        console.log(this.name);
    },
    print1: function() {
        var fun =(function(){
            console.log(this.name);
        })()
    },
	print2:()=> {
        console.log(this.name);
    },
	print3:function(){
        (()=> {
        	console.log(this.name);
        })();
    }
}
var obj2 = {
    name: "inner2"
}
obj.print();//inner;
obj.print1();//outer
obj.print2();//outer
obj.print3();//inner
var p1 = obj.print;
p1(); //outer;
/*有三个方法可以改变this,call,apply,bind 
call和apply的参数不同,call传递多个参数,apply则是传递一个数组,借助这一点我们通常用apply帮数组借用方法
bind 会返回一个固定this的方法,这样不需要每次都改动*/
Math.max.apply(null,[1,3,5]);//5
var print = obj.print.bind(obj2);
print();//inner

/***闭包***/
//闭包即内部函数访问外部变量,闭包功能强大,能帮我们实现一些很好的组件,但是闭包使得外部函数的活动对象不能释放,可能会造成内存泄漏,且闭包访问的是外部变量的最终状态,不能保留中间状态
function Person(name) {
    this.name  = name;
}
function fun1() {
    var obj = new Person("闭包");
    // return function () {
    // 	eval("");    eval()同样会使obj不会回收
    //window.eval("");会改变环境不会引用当前环境,改为引用window
    // }
    function innerfun() {
        console.log(obj.name)
    }
    return innerfun
}
var f1 = fun1();
//以上方法执行完obj不会被回收,只有 f1 = null才会回收
//new Function()通常会与eval()一起出现,但是其实它们是有区别的,eval会绑定当前的活动对象,而new Function 绑定的是全局的活动对象
```

[![W2GFzj.png](https://z3.ax1x.com/2021/07/25/W2GFzj.png)

[![WguLLD.gif](https://z3.ax1x.com/2021/07/25/WguLLD.gif)](https://imgtu.com/i/WguLLD)

](https://imgtu.com/i/W2GFzj)

#### 4.宏与微,EventLoop

JavaScript 是一门单线程的语言,尽管有了Web Worker,但是也只是借助浏览器加强,运行环境不同,资源不能共享,没有改变单线程的本质,然而JavaScript又是非阻塞的,这是通过EventLoop实现的.为了协调事件、用户交互、脚本、呈现、网络等等，用户代理必须使用事件循环

每个“线程”都有自己的事件循环，因此每个 web worker 都有自己的事件循环，所以它可以独立执行，而同一起源的所有窗口共享一个事件循环，因为它们可以同步通信。事件循环不断运行，执行任何排队的任务。一个事件循环有多个任务源，可以保证该源中的执行顺序(例如 IndexedDB 定义了它们自己的规范) ，但是浏览器可以在循环的每个环节中选择从哪个源中执行任务。这允许浏览器优先选择性能敏感的任务，比如用户输入。

宏任务(MacroTask)

```js
Script主体,setTimeout,setInterval,setImmediate,I/O, UI rendering
```

微任务(MicroTask)

```js
Promise,Process.nextTick,MutationObserver,async
```

任务循环中有一个或多个任务队列,每个任务队列是一组任务(例如事件回调是一个队列,setTimeout的回调是另一个),微任务队列不是任务队列,所有的微任务都会在同一个队列.

首先执行主线程的同步任务,遇到宏任务便把宏任务的回调添加到宏任务队列,遇到微任务则把微任务添加到微任务队列,当当前任务结束,即没有正在运行的任务且执行上下文堆栈为空时,执行微任务检查点,如果有微任务则清空微任务队列,清空之后会执行requestAnimationFrame的动画任务,然后渲染,然后再执行下一个宏任务......也就是每个宏任务结束就进行微任务检查,需要注意的微任务执行时会清空任务队列,也就是在微任务中执行微任务,那么这个微任务会接着执行(无延迟,无响应时间的情况).这也是宏任务的轮询不会卡死,而微任务的轮询会卡死的原因.

```js
setTimeout(()=>{ //相当于一个任务
    console.log("setTimeout1");
    Promise.resolve().then(data => {
        console.log(222);
    });
});
setTimeout(()=>{//另一个任务
    console.log("setTimeout2");
});
Promise.resolve().then(data=>{
    console.log(111);
});
// 111 setTimeout1 222 setTimeout2

```

[![otIzss.md.png](https://z3.ax1x.com/2021/12/02/otIzss.md.png)](https://imgtu.com/i/otIzss)

Node的事件循环是libuv控制的

[![WXWFns.png](https://z3.ax1x.com/2021/07/31/WXWFns.png)](https://imgtu.com/i/WXWFns)

[![WXWGAx.png](https://z3.ax1x.com/2021/07/31/WXWGAx.png)

[](https://imgtu.com/i/WXWGAx)

[![WXWxbR.png](https://z3.ax1x.com/2021/07/31/WXWxbR.png)](https://imgtu.com/i/WXWxbR)

```js
//关于setTimeout与setImmediate的执行顺序
setTimeout(() => {
    console.log('timeout');
  }, 0);
setImmediate(() => {
    console.log('immediate');
  });

//以上代码有两种结果,都有可能在前
//而在轮询阶段中,也就是I/O回调中则immediate会先执行.setTimeout 的最小设置延迟是 1ms; 超过4层 >=5 则为4ms

```



#### 2. ES5

```js
/*****严格模式*******/
/*这算是最大的改变了,为提高可靠性,增加了限制性,严格模式有全局的和方法内的,且严格模式方法内的不影响定义在外部其他方法,需要放在所有的语句前边*/
function fun() {
    "use strict";
    function inner() {
       console.log(a = 1);  
    }
    inner(); //a is not defined 受到影响
    //outer();// 1,不受严格模式影响
}
function outer() {
   console.log(a = 1,a);  
}
//不声明的变量赋值会报错
a = 1;//a is not defined
//静默失败会抛出异常(给关键字赋值,给只读属性赋值,给不可扩展对象增添属性)

//删除不可删除的属性

//参数名唯一
function sum(a, a, c) { // !!! 语法错误
  "use strict";
  return a + a + c; // Duplicate parameter name not allowed in this context
}
//禁止8进制

//进制给原始类型设置值
  false.true = "";      //Cannot create property 'true' on boolean 'false
//禁止使用with
//eval()不在影响外部作用域,且外部使用严格模式则eval也是严格模式
//禁止删除变量
  var x;
delete x; //Delete of an unqualified identifier in strict mode.

//argument 不会随着参数改变而变化,不再支持argument.callee

//严格模式下通过this传递给函数的值不再封装成对象,在非严格模式下基本类型会被转化为基本封装类型,默认this为window;严格模式下默认为undefined.
"use strict";
function fun() { return this; }
console.assert(fun() === undefined); 
console.assert(fun.call(2) === 2);
console.assert(fun.apply(null) === null);
console.assert(fun.call(undefined) === undefined);
console.assert(fun.bind(true)() === true);
//fun.caller,fun.callee,fun.arguments都不能使用
'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arg

//禁止了不在脚本或者函数层面的函数声明,必须在顶层声明函数
"use strict";
if (true) {
  function f() { } // !!! 语法错误
  f();
}

for (var i = 0; i < 5; i++) {
  function f2() { } // !!! 语法错误
  f2();
}

/*****新增了一些方法*********/
//像JSON的parse,stringify;Object的keys,create,defineProperty;Array的isArray,map,forEach,reduce,indexOf;function的bind等这些我们常用方法就是本次新增的

```

#### 3. ES2015

```js
/*** let const ***/
//let const 命令,es6新增了let const命令,这两个命令看似简单,但是却带来了块级作用域和死区的概念,没有声明
//1. {}内有效
{
	let a = 1;
    const b = 2;
}
console.log(a); //a is not defined
//console.log(b); b is not defined

//2. 没有变量提升,反而有死区
let a = 1;
function letDemo() {
    console.log(a); //Cannot access 'a' before initialization
    at letDemo
    let a = 2;
}
letDemo();
//3. 不会在全局对象上添加属性
let b = 2;
typeof window.b;//"undefined"
//4. 不允许重复声明
let a = 1;
let a = 10; //Identifier 'a' has already been declared
//5.function 在块级作用域向函数级作用域下变量提升不再提升整个方法,而类似于var
df(); // df is not a function
if(true) {
    function df() {
        return 1
    }
}
if(true) {
    df1();//1
    function df1() {
        return 1
    }
}
//6.作用域必须有{},
if(true) 
    let x = 1; //Lexical declaration cannot appear in a single-statement context
//7.if的()和{}是父子作用域的关系
for(let i = 0;i <= 3;i++){
   let i = "abc";
    console.log(i); //"abc"(3)
}
/*** 解构赋值 ***/
//1.数组
let [a,b,c] = [1,2,3];
a; //1
//数组的解构赋值需要右侧的对象有Iterator接口,按照遍历顺序依次赋值
let [x = 1,y = 2] = ["a"];
x;// "a"
y;// 2
[x,y]= [y,x];//通过赋值交换值
x;//2
y;//"a"
//在赋值的时候可以使用默认值,需要注意的是只有值===undefined时才会采用默认值
//2.对象
let {name,age} = {name:"小明",age:18};
let {name:name,age:age} = {name:"小明",age:18}
name;//"小明"
//第一行是第二行的简写,其中键是对应的,值才是用来赋值的
let {name:name1,age:age1} = {name:"小明",age:18}
age1; //18
//5种基本封装类型可以当成对象
let {toString} = 1;
toString.apply(1)//"1"
//多层嵌套
let people = {
    name: "小明",
    partner: {
        name: "小红"
    } 
}
let {name,partner,partner:{name:partnerName}} = people;
partnerName;//小红
partner;//{name:partnerName}
//对象扩展赋值可以通过多次使用同一个键来给不同层次的值赋值

/****字符串相关****/
//1.字符串模板
let name = "小明";
let age = 18;
function introduction(arr,...params) {
    console.log(arr,params);
}
let str = `This is ${name}`; //"This is 小明"
introduction`This is ${name}${age} \u5C0F\u660E`;
//["This is ","",""," 小明",raw] ["小明",18]
//raw:["This is ","",""," \u5C0F\u660E"]; arr最后一个raw里放得是和arr相同但是没有转移的原始值
//2.转义
//字符串会转义unicode码,如上
"\u5C0F\u660E" //小明
/*需要注意的是utf-8中 0xD800 - 0xDFFF是不能单独出现,代表了大于0xffff的字符,例如"𠮷"的unicode编码为
00020BB7对应的 utf-16BE D842DFB7 两种表示方式*/
"\u{20BB7}" //𠮷,es6新增的{}表示大于ffff的字符
"\uD842\uDFB7" //𠮷
//String.fromCodePoint(0x20BB7) fromCharCode charCodeAt
//fromCodePoint 返回指定位置的unicode编码对应的值 认识0x20BB7
//fromCharCode 将unicode转为值 不能识别大于0xffff的字符
//codePointAt 返回10进制码点
//charCodeAt 返回指定索引的unicode值不能识别大于0xffff 返回10进制码点
//String.raw()对特殊字符进行转义
String.raw`\a`; //\\a
String.raw(raw).
//includes
"str1".includes("str");//true 判断子串返回boolean
//startsWith
"str1".startsWith("str");//true 是否以某字符串开始
//endsWith
"str1".endsWith("str1");//true 是否以某字符串结尾
//repeat
"a".repeat(2) //"aa" 返回一个重复n次的字符串
//padStart,padEnd 
"25".padStart(4,"0"); //"0025" 补全字符 第一个为总位数,第二个参数为填补的字符串,不足的重复,足够的截取
"25".padEnd(4,"0123"); //"2501" 与上边相同,在结尾补齐
//trim,trimStart,trimEnd  去空格字符
/****正则****/
//正则添加了对大于0xffff字符的修饰符/u,同时增加了构造方法的参数方式
let test1 = new RegExp("abc","i");
let test2 = new RegExp(/abc/g);
let test3 = new RegExp(/abc/g,"i"); //新增的,第二参数会覆盖掉第一个参数的修饰符部分
/^\uD83D/u.test('\uD83D\uDC2A'); //false  0xD83D在0xD800和0xDFFF之间表示的大于0xffff的字符与0xDC2A是一个整体不是单独的字符,所以匹配失败
/^\uD83D/.test('\uD83D\uDC2A'); //true 如果不添加u修饰符,则不能识别0xD83D,会匹配成功
/^.$/.test("𠮷");//false .是匹配换行符以外一个字符,因为"𠮷"大于0xffff所以不能识别
/^.$/u.test("𠮷");//true 添加u后成功
/^.$/u.unicode; //通过unicode判断是否有修饰符
//还添加了修饰符y,y为粘性匹配y与g类似,全局匹配,但是多次匹配必须从头lastIndex就开始匹配,而g则是后边有就可以
let r = /a+/g;
let r1 = /a+/y;
let str = "aaa-aa-a";
r.exec(str); //aaa
r.exec(str); //aa
r1.exec(str); //aaa
r1.exec(str); //null
r1.sticky;//true 判断是否有y修饰符
//新增属性
r1.flags // "y" 返回修饰符
r1.source //"a+" 返回正文

/****Number****/
//1.二进制和八进制
0b10;//2 0b二进制符号
0010; // 8 0o八进制符号
//2.数值分隔符
123_321;//123321 数值分隔符,目前看来只是为了更友好,部分方法不能识别(Number,parseInt,parseFloat)
//3. Number.isFinite(),Number.isNaN()
Number.isFinite("12"); //false 相较于isFinite,不会进行类型转换
isFinite("12"); //true
Number.isNaN("NaN");//false 区别同上
isNaN("NaN"); //true
//4.Number.isInteger();
Number.isInteger(3.0000000000000002);//true 需要注意精度问题
//5.Number.EPSILON
Number.EPSILON;//2.220446049250313e-16 2**-52 最小精度
//6.安全整数
Number.MAX_SAFE_INTEGER; //2**53 - 1 因为2**53 === 2**53+1,向偶舍入进位的原因
Number.MIN_SAFE_INTEGER; 
Number.isSafeInterger(); //判断是否属于安全范围
//7.新增方法 应用场景
Math.trunc();//去除小数部分 不为数值的返回NaN
Math.sign();//判断是正负零(+1,-1,0),不为数值返回NaN
Math.cbrt(8);//2 计算立方根 NaN
Math.clz32();//转化为32位的无符号数返回前置零
Math.imul();//把参数转为32带符号数相乘返回带32的乘积
Math.fround(); //返回一个数的32位单精度浮点数行驶
Math.hypot();//平方和的平方根
Math.expm1(x); //返回e**x-1 Math.E 2.718281828459045;Math.expm1(1)1.718281828459045
Math.log1p(x); //返回Math.log(1 + x); Math.log(Math.expm1(1)); 
Math.log(Math.expm1(1))//1
Math.log10(),Math.log2()//没啥说的,名字即注释
//双曲函数方法.....标记一下,没研究


/****方法****/
//1.参数默认值 需要注意的是 一旦设置了默认值,或解构值,扩展运算符就不能用严格模式,严格模式会限制参数
function fun(x=1,y=2) {
    return x+y
}
fun();//3, 需要注意的只要undefined才会默认值
fun.length //0 需要注意的是,默认值会影响参数个数,从头开始,遇到默认值结束计算
function funParam(x,y=2,z) {}
funParam.length;//1
function fun1({x=1,y=2} = {}){
    return x+y
}
fun1();//3 与解构默认值配合  undefined=>{}=>{x=1,y=2}
//2.rest 参数
function fun(a,...args) {
    return args
}
fun(1,2,3);//[2,3],可以理解为args展开后是所传递的参数,把多个参数转为一个数组
fun.length //1,rest只能当最后一个参数,切不能算在参数中
//3.name 方法的名字,匿名的函数表达式会用变量名为名字,匿名函数与箭头函数的name为"",(new Function())为"anonymous",bind方法会带有bound,对象的get,set方法没有name,需要通过属性描述拿到
(function demo(){}).bind(null).name //"bound demo"
let obj = {
    name: "小明",
    get getName() {
        return this.name
    }
}
obj.getName.name;//undefined ,如果没有返回值会报错,添加get,set方法的同时会添加相应的属性,如果get有返回值则属性有值,若无返回则为undefined undefined的name自然会报错
const descriptor = Object.getOwnPropertyDescriptor(obj, 'getName');
descriptor.get.name //"get getName"
//如果对象的方法是Symbol值
const key1 = Symbol('description');
let obj = {
  [key1]() {},
};
obj[key1].name //"[description]"

//4.箭头函数,需要注意的箭头函数中的this与通常的this不同,通常的this是运行中得知,而箭头函数的静态的不变的,父作用域的this
let add = n => n+1
add(1);//2 非常简单的写法 
let sum = (n,m) => {return n+m}
//5.尾调用,尾调用即在函数内部最后调用其他函数,不参与其他运算,相关数值通过参数传递且不构成闭包,可以进行尾递归优化,不需要保存上一次调用的执行情况
//Trampolining  蹦床函数,tco优化


/****数组****/
// 1.扩展运算符 ... 任何实现了Iterator接口的对象都能够被展开为单独像
console.log(...[1,2,3]);//1 2 3 需要注意的是...不能单独使用,不能当做表达式 ...[1,2,3];(...[1,2,3])都会报错,可以当做参数,起到类似apply的参数转化效果.
console.log(..."abcdef");//a b c d e f
Math.max(...[3,4,2,1]);//4

//2. Array.from(obj,callback); 将类似数组的对象和可遍历的对象转为数组,必须有length属性
Array.from({"a":1});//[] 没有length返回空数组
Array.from({0:1});//[] 没有length返回空数组
Array.from({"a":1,length:1}); //[undefined] ,没有与索引对应的键
Array.from({"1":1,length:2},n=>n||0);//[0,1] unfedined被转化为0
const map = new Map([
  ['name', '小明'],
  ['age', 18]
]);
Array.from(map);//[["name","小明"],["age",18]]需要注意的是Map对象会把每项键值转化为一个长度2的小数组
//3.Array.of();将几个值生成数组,与构造方法不同,没有参数重载
Array.of("a",1); //["a",1]
//4.find,findIndex,第二个参数用于指定this,不过对箭头函数无效
[1,2,3,4,5].find((n,index,arr)=>{return n%5==0}) //5  返回符合的值,没有返回undefined
[1,2,3,4,5].findIndex((n,index,arr)=>{return n%5==0}) //4 返回符合的索引,没有返回-1
//5.fill与copyWithin
Array(3).fill(1); //[1,1,1]
Array.of(1,2,4,4).fill(3,2,3); //指定填充的范围,同样允许负值
Array.of(1,2,3,4,5).copyWithin(0,2);//[3,4,5,4,5],copyWithin从0开始填充2到结尾处的数值,允许负值,负值时倒数索引,但是第二个参数代表的索引要小于第三个参数代表的索引
//6.entries(),keys(),values() 返回Iterator对象用于for of 遍历,也可以用next自行遍历
let arr = [3,2,1];
for(let [key,value] of arr.entries()) {
    console.log([key,value]) //[0,3][1,2][2,1]
}
//flat,flatMap 展开数组
[1,2,[3,[4]]].flat();//[1,2,3,[4]] 参数为展开的层数,默认为1

[1,2,3,4].flatMap(n=>[[n]]); [[1],[2],[3],[4]] //flatMap对处理后的结果展开,只能展开一层 
//空值
let arr = new Array(3);//生成一个长度为3的数组,没有值
arr.length//3 有长度
0 in arr //false 没有索引
arr.map((n,index)=>index);//[empty*3],map方法跳过
console.log(...arr);//undefined undefined undefined,但是ES6的方法不会跳过,多半会转为undefined,undefined又会转为""

/**** 对象 ****/
//1.简写 需要注意的是简写的方法不能当做构造函数
let name = "小明";
let obj = {
    name,
    introduction(){
        console.log(this.obj)
    }
}
//2.字面量定义对象时,键值可以使用表达式
let key = "hobby";
let obj = {
    [key+1] :"篮球",
    [key+2] :"足球",
    [{key}] :"错误"
}
obj//{hobby1: "篮球", hobby2: "足球", [object Object]: "错误"}
//3.可枚举属性 enumerable
/* 可以通过Object.defineProperty()定义可以给对象定义属性描述符*/
var obj = {
    name:"小明"
}
var  son = Object.create(obj);
son.age = 18;
var key = Symbol("demo");
son[key] = "测试";
Object.defineProperty(son,"secret",{});//默认为不可枚举
son.propertyIsEnumerable("secret");//false 
for(let key in son) {
    console.log(key); //name age 包含继承来的
}
Object.keys(son); //["age"] 只有自己可枚举不包括Symbol
Object.getOwnPropertyNames(son); //["secret","age"] 包含不可枚举的
Object.getOwnPropertySymbols(son);//[Symbol(demo)] 
Reflect.ownKeys(son);//["secret", "age", Symbol(demo)] 不返回继承来的
//4.super 指向原型对象,只能在对象的简写方法中使用
//5.Object.is判断两个值是否相等
Object.is(+0,-0);//false
Object.is(NaN,NaN);//true
//6.Object.assign() 合并对象,第二个参数为合并的主对象,把其他对象的参数合并到主对象,并返回主对象,返回的的对象和主对象是同一个对象.若有相同属性则后边覆盖前边,可以把第一个参数设为{}用来浅拷贝
//7.Object.getPrototypeOf() Object.setPrototypeOf();用来设置或获取对象的的原型
//8.Object.entries();keys();values()与数组类似; Object.fromEntries()把键值对数组转为对象,把Map转为对象可以与URLSearchParams配合转get参数为对象
let search = "?name=小明&age=18" //代替location.search
Object.fromEntries(new URLSearchParams(location.search));//{name: "小明", age: "18"}


/**** 运算符 ****/
//**ES6就增加了 **来代替pow   
Math.pow(2,3);//8
 2**3; //8

/**** Symbol ****/
//1.Symbol作为新的一种类型,表示唯一的,可以传参作为描述,Symbol不能隐式的转换,可以强转为string和boolean,需要注意的是当Symbol当为对象的键时可以被getOwnPropertySymbols()方法获得,不是构造方法

let a = Symbol();
let b = Symbol("描述");
typeof a;//"Symbol"
b.description; //"描述" ES2019新增
let c = Symbol.for();//
let d = Symbol.for();// Symbol.for()类似 单例模式,如果已经存在此描述则返回,不存在则创建,而Symbol()每次都是返回一个新的唯一值,所以每个Symbol()生成的都不相同且不与Symbol.for()生成的相同;
c === d //true
Symbol.keyFor(c); //"undefined",keyFor则是返回for方法产生的symbol的描述值

//2.内置方法,进行js元编程,改变js的默认行为
class MyClass {
    [Symbol.hasInstance](foo) {
        return foo instanceof Array;
    }
}
[1, 2, 3] instanceof new MyClass() // true hasInstance会在 instance命令的时候调用,也可以给对象字面量添加,但是不能对构造方法添加,但是instanceOf可以对构造方法使用
let arr = [1,2,3];
arr[Symbol.isConcatSpreadable] = false;
[].concat(arr);//[Array(3)] 表示concat时对象是否会展开,如果设为false则对象当做数组的一个值,这里的对象特指数组以及数组形状对象
class MyArray extends Array {
  static get [Symbol.species]() { return Array; }//Symbol.species用来改变像map一样的派生类的构造方法指向,Symbol.species是不可改变不可扩展的,属于类的,所以只能用get读取,写法必须严格带有static get
}
const a = new MyArray(1,2,3);
const b = a.map(x=>x+1);
b instanceof MyArray //Symbol.species默认返回this,此时为true,修改后返回Array此时为false

class MyMatcher {
  [Symbol.match](string) {
    return 'hello world'.indexOf(string);
  }
}
'e'.match(new MyMatcher()); //拦截match方法,自定义规则
const x = {};
x[Symbol.replace] = (...s) => console.log(s);

'Hello'.replace(x, 'World') //拦截replace方法,传入字符串和替换字符串,同样的还有serach,split

const myIterable = {};
myIterable[Symbol.iterator] = function* () {
  yield 1;
  yield 2;
  yield 3;
};
for(let key of myIterable){console.log(key)}//1 2 3 
let iter = myIterable[Symbol.iterator]();
iter.next();//{value: 1, done: false} 也可以用next()一步一步的调用

let obj = {
  [Symbol.toPrimitive](hint) {
    switch (hint) {
      case 'number':
        return 123;
      case 'string':
        return 'str';
      case 'default':
        return 'default';
      default:
        throw new Error();
     }
   }
};
obj * 1; //123  *和-,/ 都是要先进valueOf()然后强转为Number
obj + 1;// "default1"  加法和比较 都是先调用对象的valueof()再toString()方法,没有强转
String(obj); //str String,alert则是直接调用toString()

({[Symbol.toStringTag]: 'Foo'}.toString()) //"[object Foo]" 修改toString的对象描述符
Array.prototype[Symbol.unscopables] //with命令排除对象的属性,使属性不能访问


/**** Map和Set ****/
//1.Set
let set = new Set();// Set是一组唯一值的集合,里边的值不会重复,NaN也不能有两个,-0和+0不会同时存在可以传递类似数组或者具有iterable接口的数据接口..与Array不同的是不支持带有length的对象
set.add(1); //通过add的添加项,返回set
set.has(1);//通过has判断项是否存在,返回Boolean
set.delete(1); //通过delete删除项,返回Boolean
set.size;//返回长度
set.clear();//清空set
set.keys();//可以通过keys(),values(),entries(),forEach遍历,需要注意的是key和value相等,而不是与数组那样key为固定值.
[...new Set([1,2,3,3,4])]//[1,2,3,4] 数组去重
//2.Map
let map = new Map(); //Map与对象的不同在于key可以是对象,而对象的建只能是基本类型,构造方法可以传递具有iterable的对象,且每个值都是双元素数组,例如对象可以通过Object.entries({})转换为Map
new Map(Object.entries({}));
map.set("key","value");//通过set设置值
map.get("key");//通过get取值
map.has("key");//判断是否有 同样有clear()和delete()方法,size属性,遍历也是
Object.fromEntries(map);//可以把Map转为对象,需要注意的是对象做key的会转为类似的[object Object],如果有多个会造成属性缺失,后边的覆盖掉前边的
//3. WeakMap WeakSet; WeakSet类似于Set,但是只能存放对象,且是对象的弱引用,当外部无引用时对象被释放,Set中的引用也被删除,所以Set的长度不定,不能遍历,没有size属性;WeapMap与Map类似和WeakSet相同Key只能是对象,弱引用不能遍历,没有size

/**** Proxy ****/
/*Proxy 代理 用于拦截对象一些操作,目前共有13种,下面展示了一些常用的需要注意的是虽然我们可以自定义内容,但是受对象是否可扩展,可写,可枚举属性限制,而且对拦截方法的返回值是有一定限制的,会对返回值进行内部的处理和判断若返回值不符合规范会进行强转,过滤甚至报错*/
var obj = {
    name: "小明",
    age: 18,
    introduce() {
        console.log(`I am ${this.name}. I'm ${this.age} years old`);
        //需要注意的是当proxy调用时,this为proxy,且会触发相应的get方法
    }
}
Object.defineProperty(obj,"weigth");

var proxy = new Proxy(obj,{
    get(target,key,receiver) {
        //调用方法或者拿值都会触发,并且一些内部方法也会触发,需要注意返回不能改变一些不可修改的值
        console.log("get",key,typeof target[key]);
        return target[key]
    },
    set(target,key,value,receiver) {//设置值触发,当属性不可写,那么设置值无效
        console.log("set",key);
        target[key] = value;
    },
    has(target,key) {// in命令触发 ,返回boolean(会强转),需要注意如果对象不可扩展那么就不能返回false
        console.log("has",key);
        return key in target
    },
    deleteProperty(target,key) {//delete 命令触发,当属性不可扩展是不能返回true
         console.log("delete",key);
    },
    ownKeys(target) {//for in entries
        console.log("ownKeys");
        return Reflect.ownKeys(target);
        //需要注意当不可扩展时,这里要把不可枚举的属性也返回,当有不可枚举的属性时,如果不返回会报错,也不能返回多余的属性,这里每个属性都会调用getPrototypeOf,getOwnPropertyDescriptor进行内部判断,所以返回的不是最终值
    },
    getOwnPropertyDescriptor(target,key) {//Object.getOwnPropertyDescriptor方法触发,有很多方法内部会调用,比如Object.entries();会先进上一步然后再回下一步
        console.log("getOwnPropertyDescriptor");
        return Object.getOwnPropertyDescriptor(target,key);
    },
    defineProperty(target,key,descriptor) {//受对象是否可扩展限制,直接返回false会报错
		 return false;
    },
    getPrototypeOf(target) {   
        console.log("getPrototypeOf");
        return Object.getPrototypeOf(target);//必须返回对象或null
    },
    setPrototypeOf()(target,obj){//返回布尔值
     	console.log("setPrototypeOf");
    	Object.setPrototypeOf(target,obj);
	},
    isExtensible() { //拦截isExtensible,返回值为boolean
        console.log("isExtensible");
    	return true;
    },
    preventExtensions() {//Object.preventExtensions()
       console.log("isExtensible");
    	return true;
    },
    apply(target,object,args) {//拦截函数的调用,call,apply的使用,此时target为方法
        console.log(object.args)
    },
    construct(target,args) {//构造方法或者Object.create()触发
        console.log("construct");
        return {}
    }
});
let {proxy, revoke} = Proxy.revocable() //返回一个可取消的Proxy,revoke()方法调用后就不再拦截
/**** Reflect ****/
//Reflect反射,对Object的13个方法(通Proxy)进行重定义,修改返回结果和写法,改变js的一些用法,能够修改自身的语言

/*reflect-metadata 装饰器*/

/**** Promise ****/
//Promise 承诺,有三种状态 pending(进行中),fulfilled(已成功),rejected(已失败)
const promise = new Promise(function(resolve, reject) {
  if (/* 异步操作成功 */){
    resolve(value);//接受
  } else {
    reject(error);//拒绝
  }
  console.log("继续执行");//resolve和reject都不会阻止方法继续执行,所以这句会打印出来
});
promise.then((resolve)=>{},(reject)=>{}).then().catch().finally();
//Promise有三个方法then(),catch(),finally();他们三个都返回一个promise对象,所以可以一直.下去,其中then()有两个参数第一个为resolve传递的参数,第二个为reject传递的参数和报错,如果使用了第二个参数,那么方法中的报错就不会传递给catch方法,反之会进catch方法,并且在catch之前的then中的错误也会被catch拦截
const p = Promise.all([p1, p2, p3]);//Promise.all,需要传递具有Iterator接口的对象,适用于多个请求同时发出,当三个全都成功或其中一个失败时返回,失败时返回失败的那个进入reject
const p = Promise.race([p1, p2, p3]);//race竞争嘛,不管是失败还是成功要第一个完成的,成功进then失败catch
Promise.resolve();//转换为返回resolve的promise对象
Promise.reject();//转换为返回reject的promise对象

/**** Iterator ****/
//Iterator遍历器接口,返回一个具有next(),[return,throw]方法的对象 每个阶段返回{done:true,value:value}直到done为true,很多类似数组的数据结构都具有默认的Iterator,比如Map,Set,arguments,nodeList和字符串,但是对象本身没有,要想用for of遍历对象需要给对象添加[Symbol.Iterator]
var arr = [1,2,3];
arr.name = "数字";
for(let i = 0; i<arr.length;i++){
    console.log(arr[i]);            // 1,2,3
}

for(let i in arr){
    console.log(arr[i])  // 1,2,3,"数字"
}

for(let i of arr){
    console.log(i)   //1 2 3
}
arr.forEach((n,i)=>{console.log(n,i)}) //0,1 1,2 2,3 不能中断
/**** Generator ****/
//协程.与一般方法不同 Generator 在方法声明的地方多了*号,在函数体中多了yield命令,当调用方法时,不执行方法,而是返回一个Iterator
function* fun() {
  try{
      for(var i = 0; true; i++) {
        var reset = yield i;
        if(reset) { i = -1; }
      }
  }catch(e){
      console.log(e);
  }
}
function* fun1(){
    yield "开始";
    yield* fun();
    yield "结束";
}
var g = fun();
g.next();//{value:0,done:false}
g.next();//{value:1,done:false}
g.next(true);//{value:0,done:false}
g.return("测试"); //{value: "测试", done: true}
g.throw(0);//{value: undefined, done: true},需要注意如果done已经为true了那么调用throw会报错,如果没有执行过next,也会报错

/*上述方法f1,当调用时不执行方法体,而是返回一个Iterator对象g,
当第一次调用next方法时,fun方法开始执行,执行完yield 0结束本次调用,当第二次调用时继续执行,执行完yield 1结束,第三次时通过传参使得reset为true重置 i为-1,执行i++后 遇到yield 0结束;
返回的g对象还具有return和throw方法,与next方法相同都是在外部改变Generator方法的途径,不同的是next用于传递参数并进行下一次调用,return用于终止Generator,done为true,throw使得方法进入catch回调(如果内部有try catch)同时done为true; Generator以return 命令结尾 返回{value:"return的值",done:true},若无return 则value为undefined;
yield*命令用于Generator嵌套,嵌套时内部的return语句不会结束外部的,但是return()方法会结束整个,throw()方法会分层捕获.需要注意的是yield命令只在Generator方法中有效,其他地方用会报错,yield*命令后可以跟一个Iterator对象,不能随意跟普通对象方法*/
/**** Generator异步与自动执行 ****/
//关于Generator异步,当yield后边跟的是异步时,无法判断是否执行完毕,一般使用Promise包装返回Promise对象这样就可以在Generator外部处理回调,也可以用Thunk函数处理,即多层函数包裹,返回一个参数为callback的方法用于外部处理,然后再用next把参数传递回去
var fs = require('fs');
var thunkify = require('thunkify');
var readFileThunk = thunkify(fs.readFile);

var gen = function* (){
  var r1 = yield readFileThunk('/etc/fstab');//返回参数为callback的方法
  console.log(r1.toString());
  var r2 = yield readFileThunk('/etc/shells');
  console.log(r2.toString());
};
function run(fn) {
  var gen = fn();

  function next(err, data) {
    var result = gen.next(data);//把结果传递进Generator
    if (result.done) return;
    result.value(next);//value 为参数为回调的方法
  }

  next();
}

/**** Class ***/
/*ES6类是ES5的语法糖*/
class Person {
    sex = -1;//需要注意的是类内定义的属性和构造方法中定义的属性不会出现在原型上
    constructor(name,age){
        console.log(new.target);//返回用new创建实例的类
        this.name = name;
        this.age = age;
    }
	get weight() {//get 增加的属性会添加到原型上
        return this.weight
    }
	set weight(weight) {
        console.log(weight);
        //在这里赋值会不停的触发set进入死循环;
    }
    introduce() {
        console.log(`我是${this.name},今年${this.age}`);
        //this表示调用此方法的对象,通常是类的实例
    }
    static describe() {//静态方法属于类不会给实例,但是可以被子类继承
        console.log(this.staticProp);
    }
 
}
//可以继承构造方法,但是不可以继承普通的对象
//普通的方法不能通过原型的形式继承js内部对象,但是类的方式可以
class Man extends Person{
   
    constructor(name,age) {
        super(name,age);//一但继承则构造方法中必须有super,调用父类的构造方法然后把this改为子类的实例,super要在this之前
        this.sex = 1;
    }
    static manStatic() {
        console.log(super.staticProp);
        //静态方法中super为父类
    }
    print () {
        //普通方法中的super是父类的原型,但是会替换this为子类的实例
        super.introduce();
        //super不能单独使用,也就是说不能打印console.log(super)
    }
}
Person.staticProp = "测试";
Man.staticProp = "子类";
let xiaoming = new Person("小明",18);
let xiaoLi = new Man("小李",18);
typeof Person;//"function"
xiaoming.constructor === Person;// true
Object.keys(Person.prototype);//[] class内的方法不可枚举
Person.describe()//测试 静态方法中的this通常指的类本身
Man.describe()//子类 继承父类方法替换为自己的this
Object.getPrototypeOf(Man) === Person//true
Man.manStatic()//"测试" 

/**** module 模块 ****/
/* 模块使用需要注意 在浏览器环境中需要设置<script type="module"/>
在node环境中需要配置package.json {type:"module"},或者把出现export和import的文件后缀名改为mjs*/
//prop.js 需要注意export后边需要跟声明或语句  export prop1是不对的
//无论是export还是import都不能使用不存在的,export不能导出不存在的,import不能引入没导出的且 import的对象是只读的不可更改
let prop1 = 1;
let prop2 = 2;
let prop3 = 3;
export {prop1,prop2,prop3}
//sum.js
export function sum(...args) {
    return args.reduce((total,n)=>total+n,0)
}
export default function(prop1,prop2){ //单个文件不能重复定义
    return prop1+prop2
}

export * from "***";  //用此方式中转 default会被忽略

//index.js
import {prop1,prop2,prop3} from "./prop.js";
import sum from "./sum.js"; //sum 代表 export default
import {default as sumTwo,sum} from "./sum,js";
import sumTwo,{sum} from "./sum,js";//sumTwo代表 export default
import * as addObj from "./sum,js";//addObj.add,addObj.default
//异步加载模块
import('/modules/myModule.mjs')
  .then((module) => {
    // Do something with the module.
  });

/**** ArrayBuffer ****/
//ArrayBuffer用于创建存放数据的一段连续内存区域 用于直接操作内存,进行二进制数据处理,不能直接操作需要借助视图(TypedArray,DataView)
const buff = new ArrayBuffer(32); //创建一个32字节的内存空间
ArrayBuffer.byteLength;//32
const newBuff = buff.slice(0,3);//复制并生成新的
ArrayBuffer.isView(newBuff);//false 判断是否为视图

//TypedArray 9种类型的视图,Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array
//每个视图只能存放同一种数据,第二个参数必须是倍数关系start offset of Int16Array should be a multiple of 2 
const view1 = new Int8Array(buff, 0, 2);//创建存放8位的有符号的视图,从第0个字节开始,创建2个,第二,三个参数可选,
const view2 = new Uint8Array(buff, 0, 2);
view1[0] = 1;
view2[0]//1 虽然是不同的视图但是是相同的内存,所以操作相互影响
view1[0] = 128;
view1[0] //-128 此时有符号位溢出 1000 0000 补码形式
view2[0] //128 因为视图的类型不同相同的内存读取的数据不同
view1[2] //虽然不会报错但是只有2个长度的视图设置第三个是无效的
const view3 = new Int8Array(8);//直接创建内存
const view4 = new Int8Array([1,2,3]); //亦可以传递个数组,但是创建的视图只是复制数组的值,操作视图对数组无影响
const typedArray = new Int8Array(new Uint8Array(4));//两个内存无影响
//大端和小端 小的数开始的为小端
const BIG_ENDIAN = Symbol('BIG_ENDIAN');
const LITTLE_ENDIAN = Symbol('LITTLE_ENDIAN');

function getPlatformEndianness() {
  let arr32 = Uint32Array.of(0x12345678);
  let arr8 = new Uint8Array(arr32.buffer);
  switch ((arr8[0]*0x1000000) + (arr8[1]*0x10000) + (arr8[2]*0x100) + (arr8[3])) {
    case 0x12345678:
      return BIG_ENDIAN;
    case 0x78563412:
      return LITTLE_ENDIAN;
    default:
      throw new Error('Unknown endianness');
  }
}
Int8Array.BYTES_PER_ELEMENT;//1 返回占得字节数 属性
view1.buffer // 指向内存区域
view1.byteLength //2 字节长度
view1.byteOffset//0 初始值
view1.length // 2成员数
const a = new Uint8Array(8);
const b = new Uint8Array(10);
b.set(a,2); //将数值从一段内存复制到另一段
const a = new Uint16Array(8);
const b = a.subarray(2,3); //新建一个视图,内存相同,会相互影响

//DateView 多种类型 通过getInt8等8个方法读,setInt8取
```



#### 4. ES2016

```js
//ES7 多了一个数组的方法 一个操作符
//includes ES6字符串新增了这个方法,在ES7也给数组新增了
let arr = [1,2,3,4,NaN];
arr.includes(NaN);//true 类似于字符串的indexOf,返回boolean,需要注意的NaN是可以匹配NaN的,这点与Object.is()类似
arr.includes(1,1);//false 第二个参数为匹配的起点

//运算符 ** 算是pow的简写吧
Math.pow(2,3);//8
2**3;//8
let a = 2;
a **= 4;
a//16
```



#### 5. ES2017

```js
// async await  与ES6的Generator与Promise相关,co包了一层Generator
/*方法声明中一旦有了async那么这个方法便返回以Promise对象,即便自己定义了返回值 那这个返回值也会被包装为Promise的data,当然如果返回的是Promise那就例外*/

function data(time) {
	return new Promise(function(reslove,reject){
        setTimeout(()=>{reslove({name:"小明"})},time)
    })
}
async function getData(){
	let name = await data(100);
    let name1 = await data(100);
    console.log(name); 
    //这样必须第一个await执行完毕后第二个才会执行,如果第一个报错那么第二个不会执行
}

async function getData1(){
    let name = data(1000);
    let name1 = data(100);
    await name;
   	await name1
    /*两个异步会同时执行,但是因为第一个先遇到await所以即便是需要等待的时间长于第二个,也会先执行第一个*/
}
/* 在ES8中await只能在async声明的函数中的使用,await会阻止程序继续执行直到await后边的异步执行完毕(如果不是异步则不停止,thenable会当做Promise)

/*关于错误处 理,一但await后边有错误,就不会继续执行,如果方法外部有catch则进入catch,但是像上边第二种写法两个异步都已经开始,第一个会被catch捕捉到,第二个不会,继续报错,第一种则不会执行第二个异步*/
async function getData(){
	let name =await data(10);
    //一但报错不继续执行进外catch,无catch则报错
    let name1 =await data(100);
    /*****分隔*******/
    try{
        let name =await data(10);
        //一但报错不继续执行进内catch,进外then
        let name1 =await data(100);
    }catch() {
        
    }
    /*****分隔*******/
    try{
        let name =await data(10);
        //报错进catch
    }catch() {
        
    }
    let name1 =await data(100);//不会受到报错影响
	    /*****分隔*******/
	//自己的错误自己处理不会影响其他
    let name =await data(10).catch();
    let name1 =await data(100).catch();
}
getData()
.then(
	function(data){
    	console.log(data,"then")
    }
)
.catch(
	function(e){
    	console.log(e,"catch")
    }
)


//一些方法上边可能有介绍
Object.values();
Object.entries();
Object.getOwnPropertyDescriptors()//获取对象的所有属性描述
padStart();
padEnd();
//尾随逗号


//SharedArrayBuffer与ArrayBuffer类似是Web worker进行数据共享
//需要注意SharedArrayBuffer在chrome里会受到跨域警告(版本91+?)

/*下边的代码主线程postMessage两次,第一次没有给内存设置,第二次通过视图设置值1,然而在worker子线程中会打印出两个1,与预期不符,这是共享内存的一个问题,可以把第二次赋值放到worker子线程的消息回调中,注意添加结束限制避免死循环*/
const w = new Worker('myworker.js');
const sharedBuffer = new SharedArrayBuffer(1024);
// 主线程将共享内存的地址发送出去
w.postMessage(sharedBuffer);
// 在共享内存上建立视图，供写入数据
const sharedArray = new Int32Array(sharedBuffer);
sharedArray[0] = 1;
w.postMessage(sharedBuffer);//发生改变就重新发送
w.onmessage = function(ev) {
    
}

// Worker 线程
onmessage = function (ev) {
  // 主线程共享的数据，就是 1KB 的共享内存
  const sharedBuffer = ev.data;

  // 在共享内存上建立视图，方便读写
  const sharedArray = new Int32Array(sharedBuffer);
  console.log(sharedArray[0])
  // ...
};

//Atomics 保证SharedArrayBuffer操作的原子性即把每条命令看做一个整体不允许其他命令插入式执行
Atomics.store(typedArray,index,value);//设置数据,返回设置值
Atomics.load(typedArray,index);//读取数据
Atomics.exchange(typedArray,index,value);//返回替换的值
Atomics.wait(typedArray,index,value,timeout);
//只要typedArray的index位置的值为value,那么休眠timeout 毫秒,如果不设置timeout那就要等待notify唤醒返回值 not-equal(不等),timed-out(超时唤醒),ok(notify唤醒)
Atomics.notify(typedArray,index,count);
//唤醒以index位置进行休眠的count个线程

Atomics.add(sharedArray, index, value)//sharedArray[index]+value
Atomics.sub(sharedArray, index, value)//sharedArray[index]-value
Atomics.and(sharedArray, index, value)//sharedArray[index]&value 与
Atomics.or(sharedArray, index, value)//sharedArray[index]|value 或
Atomics.xor(sharedArray, index, value)//sharedArray[index]^value 异或

Atomics.compareExchange(sharedArray, index, oldval, newval)
//类似于三目,sharedArray[index]==oldval则sharedArray[index]=newval返回oldval
Atomics.isLockFree(size)//判断size是否为校验能够使用原子操作TypedArray的标准字节长度之一 Int8Array 对应的size是1


const w = new Worker("work.js");
const sharedBuffer = new SharedArrayBuffer(1024);
const sharedArray = new Int32Array(sharedBuffer);
Atomics.store(sharedArray, 0, 1);
w.postMessage(sharedBuffer);
w.onmessage = function (event) {
  Atomics.add(sharedArray, 0, 1);//每次加1
  w.postMessage(sharedBuffer);
};
polling(1000);//1s轮询1次为3则激活设值为7
function polling(time) {
  if (Atomics.load(sharedArray, 0) == 3) {
    Atomics.store(sharedArray, 0, 7);
    Atomics.notify(sharedArray, 0, 1); //激活
    return;
  }
  setTimeout(function () {
    polling(time);
  }, time);
}

// Worker 线程
onmessage = function (ev) {
  const sharedBuffer = ev.data;
  const sharedArray = new Int32Array(sharedBuffer);
  console.log(Atomics.load(sharedArray, 0));//1,2,3 8,9
  Atomics.wait(sharedArray, 0, 3);//为3则休眠
  Atomics.wait(sharedArray, 0, 9);//为9则休眠
  postMessage("ok");
};
```



#### 6. ES2018

```js
/*****异步迭代器*****/
function doSomething(i) {
	return new Promise(function(res,rej){
		setTimeout(()=>{res(i)},1000)
	})
}
//之前的写法
async function foo(array) {
  for (let i of array) {
    console.log(await doSomething(i));
  }
  console.log("end");
}
foo([1,2,3,4]) //1,2,3,4 end

//for await 是用来遍历异步迭代器的,与上边的写法并不相同,遍历对象需要是异步的具有迭代器的对象
//这种写法没有意义,与for没什么区别,不会阻塞
async function foo(array) {
  for await (let i of array) {
    doSomething(i)
  }
   console.log("end");
}
//这是正确的用法
async function foo(array) {
  for await (let i of array) {
    console.log(i);
  }
   console.log("end")
}
foo([doSomething(1),doSomething(2),doSomething(3),doSomething(4)]);//1,2,3,4
//这种写法同时调用,顺序回调,每次循环之间不会阻塞但是会堵塞for await后边的语句类似于
let a = doSomething(1);
let b = doSomething(2);
await a;
await b;
console.log("end")

//用来遍历异步迭代器
async function* asyncGenerator() {
  let i = 0;
  while (i < 3) {
    yield i++;
  }
}
(async function() {
  for await (let num of asyncGenerator()) {
    console.log(num);
  }
})();

/******Promise.finally()*****/

/******Rest/Spread******/
//给对象也添加了原先数组的Rest/Spread功能
let {a,b,...obj} = {a:1,b:2,c:3,d:4}
a//1
b//2
obj//{c:3,d:4}
//需要注意的是对象是没有Iterator接口的不能直接使用...
console.log(...[1,2,3])//1 2 3
console.log(...{a:1,b:2,c:3,d:4})//报错
//需要在{}中使用
let e = {e:5,...{a:1,b:2,c:3,d:4}};
e//{e: 5, a: 1, b: 2, c: 3, d: 4}


/****正则表达式命名捕获组与后行断言****/

const RE_DATE= /(\d{4})-(\d{2})-(\d{2})/;
RE_DATE.exec('2021-12-31');
//["2021-12-31","2021","12","31",index:0,input:"2021-12-31",groups:undefined]
//正则表达式的exec方法是专门为捕获组设计的,如果匹配则返回一个数组,第一个值为匹配整个正则的字符串,然后依次是每个()内匹配的字符串,三个()便是3组,不匹配返回null
//ES2018以 ?<name>的形式为每个分组具名
const RE_DATE = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/;
RE_DATE.exec('2021-12-31');
//和上边一样只是groups有了对应的值,groups: {year: "2021", month: "12", day: "31"}
const RE_TWICE = /^(?<word>[a-z]+)!\1$/;  
RE_TWICE.test('abc!abc') // true
RE_TWICE.test('abc!ab') //false
const RE_TWICE = /^(?<word>[a-z]+)!\k<word>$/;  //引用
RE_TWICE.test('abc!abc') // true
RE_TWICE.test('abc!ab')//false

let re = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/u;

'2021-12-22'.replace(re, '$1/$2/$3') // "2021/12/22"
'2021-12-22'.replace(re, '$<month>$<day> $<year>') //12 22 2021


//后行断言
//(?:pattern)不成捕获组
/Window(s|2000)/ //会有一个捕获组
/Window(?:s|2000)/  //不会生成组 



 //(?=pattern)正向肯定预查
/Windows(?=2000)/.test("Windows2000") //true 后边跟2000的Windows
//(?!pattern) 正向否定预查
/Windows(?!2000)/.test("Windows200") //true  后边不跟2000的windows

// (?<=pattern) 反向肯定预查 
/(?<=2000)Windows/.test("2000Windows")//true windows前边是2000
//(?<!pattern) 反向否定预查
/(?<!2000)Windows/.test("200Windows")//true windows前边不是2000

/*所谓预查,即预查的部分不计入返回结果,像正向预查的部分是下一预查的开始*/
let demo = /Windows(?=W)/g
demo.exec("WindowsWindowsWindows")
//["Windows", index: 0, input: "WindowsWindowsWindows", groups: undefined]
demo.exec("WindowsWindowsWindows")
//["Windows", index: 7, input: "WindowsWindowsWindows", groups: undefined]
demo.exec("WindowsWindowsWindows")
//null
//可以看到返回结果中没有第二个W,且可以匹配两次


/****  \p{...} \P{...} ****/
//匹配Unicode属性需要添加u修饰
const regexGreekSymbol = /\p{Script=Greek}/u;
regexGreekSymbol.test('π') // true 匹配希腊字符
// 匹配所有数字
const regex = /^\p{Number}+$/u;
regex.test('²³¹¼½¾') // true
regex.test('㉛㉜㉝') // true
regex.test('ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫ') // true
```

#### 7. ES2019

```js
//Array.flat()和Array.flatMap() 
//String.trimStart()和String.trimEnd()
//Object.fromEntries()
String.prototype.matchAll
const string = 'test1test2test3';
const regex = /t(e)(st(\d?))/g;
string.match(regex); //["test1", "test2", "test3"]//只返回结果,不返回捕获组
let iter = string.matchAll(regex); //返回一个RegExpStringIterator
for(let key of iter){
    console.log(key);//返回所有的捕获组对象
}

Symbol.prototype.description //返回描述符
//catch的参数可以不传
try{
    /***/
}catch(e) {
     /***/
}
try{
}catch{   
}
//JSON JSON.stringify 遇到0xD800到0xDFFF之间的单个码点或者不存在的配对形式，它会返回转义字符串，留给应用自己决定下一步的处理。

//Function.prototype.toString() //会连注释和空格一起返回
function /* foo comment */ foo () {}
foo.toString()
//"function /* foo comment */ foo () {}"
//Array.prototype.sort()变得稳定使得每次的结果相同 
/*堆排序、快速排序等是不稳定的,插入排序、合并排序、冒泡排序是稳定的*/
```

#### 8. ES2020

```js
/**** 两个运算符 ?. ?? ****/
// 错误写法，当某一层级值为null或undefined时，会报错
const userName = list.info.base.userName;
// 正确写法（我们常用的方式）
const userName = (list && list.info && list.info.base && list.info.base.userName) || 'userName';
//新增的链式判断运算符
const userName = list?.info?.base?.userName || 'userName';

var list = {
	info: {
		base:{
			userName:"小明"
		}
	}
}
var userName = list?.info?.base?.userName || 'userName'; //"小明"
list.info.base = {};
var userName = list?.info?.base?.userName || 'userName';//"userName"

a?.()//如果a方法存在则执行,可能因为a不是方法报错
a?.[x] 
(a?.b).c//()包裹的是一个表达式,所以不会短路.c
foo ?.3 //会报错,需要 foo.3就是会报错,不管是否是(?. 与 ? .3的歧义)   foo?.[3] 
//??符号判断是否为null和undefined是则赋予默认值,平常我们无论是if还是三目判断 总会把0和false一些不希望当做非值的当做非值,可以使用??=来赋值但是如果短路则会报错
let a = 0;
a??1;//0
null??1//1
list?.info?.base?.userName ?? 'userName';
//需要注意??只是返回默认值并不会建立路径赋值给userName
1 && 0 ?? 2 //报错 多个运算符需要添加()表明优先级

function getdata(id) {
	if(id??1){
		console.log(1)
	}
}

//import()  在这之前import命令在编译时执行,只能在顶级使用,不能动态判断动态引入,运行时引入
import(`./section-modules/section.js`)
  .then(module => {
   
  })
  .catch(err => {
  });

export * as ns from 'module'; //把模块加载到当前模块再导出
import * as ns from "mod";
export {ns};

//BigInt 以前js都是64位浮点数,ES2020引入BigInt大整数可以表示任何整数,没有位数限制为了与Number区别需要加后缀n
const a = 11111111111111111111111111111111111111111111111111111111111111111n;
typeof a; //"bigint"老传统小写的是类型
0b1101n // 二进制
0o777n // 八进制
0xFFn // 十六进制
1n == 1;//true
1n === 1;//false
+1n//会报错
//BigInt 强转,只有能够转换为整数数值的才能强转为BigInt,浮点和NaN都不行
BigInt(123); //123n
BigInt(true);//1n
1n.valueOf()//1n
1n.toString()//1n
1n.toLocaleString() //1

//需要注意
 String(1n);//1
1n+"23"; "123"
8n/3n //2n
//可以参与比较运算,但是不能参与算数运算,不能进行无符号移动,BigInt是有符号的,BigInt的计算会向下取整
BigInt.asUintN(width, BigInt);// 0 到 2width - 1
BigInt.asIntN(width, BigInt);// -2width - 1 到 2width - 1 - 1
const max = 2n ** (64n - 1n) - 1n; //64位有符号数的最大值
BigInt.asIntN(64, max);//9223372036854775807n
BigInt.asIntN(64, max+1n);//-9223372036854775808n 进位为负数以补码的形式存在
BigInt.asUintN(64, max + 1n);//9223372036854775808n 无符号数不受影响
BigInt.parseInt(string[, radix])
//BigInt不能进行json转换,自己实现toJSON()

JSON.stringify(1n)//报错
BigInt.prototype.toJSON = function() { return this.toString(); }
JSON.stringify(1n)//"\"1\"" 会转义


//globalThis 代表全局环境
/*浏览器主线程中 globalThis代表 window,web worker中 代表DedicatedWorkerGlobalScope
node中代表global */

//Promise.allSettled
//Promise.all()代表所有的都成功或者第一个失败,allSettled代表所有的都完成不管是成功还是失败
var pro1 = new Promise((resolve,reject)=>{
   reject(1); 
});
var pro2 = new Promise((resolve,reject)=>{
   resolve(2); 
});
var pro3 = new Promise((resolve,reject)=>{
  setTimeout(function(){
      resolve(3)
  },1000)
});

Promise.allSettled([pro1,pro2,pro3]).then(function(data){
    console.log(data,"success");
},function(data){ console.log(data,"err");})
/*
[0: {status: "rejected", reason: 1}
1: {status: "fulfilled", value: 2}
2: {status: "fulfilled", value: 3}]*/


```

#### 9. ES2021

```js
//replaceAll 类似于replace使用正则加了g修饰符,需要注意的是replaceAll一但用正则则必须加g
'aabbcc'.replace("b","_"); //"aa_bcc"
'aabbcc'.replaceAll("b","_"); //"aa__cc"
'aabbcc'.replace(/b/g,"_"); //"aa__cc"
'aabbcc'.replaceAll(/(?<=\w)(?=\w)/g,"_");//"a_a_b_b_c_c"
//Promise.any
//Promise.race()只要有一个改变状态,整个就改变,第一个改变的就是race的返回; Promise.any 只要一个成功那么就进resolve回调,所有的都失败才进reject回调
Promise.allSettled([pro1,pro2,pro3]).then(function(data){
    console.log(data,"success");
},function(data){ console.log(data,"err");})
//2 "success"
// AggregateError: All promises were rejected "err" 全部失败时


//WeakRefs 弱引用 类似于 WeakSet WeakMap
let target = {};
let wr = new WeakRef(target);
wr.deref();//如果对象存在返回对象否则返回undefined 标准规定，一旦使用WeakRef()创建了原始对象的弱引用，那么在本轮事件循环（event loop），原始对象肯定不会被清除，只会在后面的事件循环才会被清除。
 //逻辑运算符和赋值表达式
x ||= y; //x = x||y
x &&= y; //x = x&&y
x ??= y; //x= x??y ??=不能与?.配合 因为短路会报错
let m = null,n = 1;
m??=n;
m//1
 //数字分隔符
 let a = 123_456.123_456;

//FinalizationRegistry 

const registry = new FinalizationRegistry(heldValue => {
  // ....
});
registry.register(theObject, "some value");//当theObject被回收"some value"被作为回调的参数调用回调此处也是弱引用
registry.unregister(theObject);//取消监控

//缓存
function makeWeakCached(f) {
  const cache = new Map();
  const cleanup = new FinalizationRegistry(key => {
    const ref = cache.get(key);
    if (ref && !ref.deref()) cache.delete(key);
  });

  return key => {
    const ref = cache.get(key);
    if (ref) {
      const cached = ref.deref();
      if (cached !== undefined) return cached;
    }

    const fresh = f(key);
    cache.set(key, new WeakRef(fresh));
    cleanup.register(fresh, key);
    return fresh;
  };
}

const getImageCached = makeWeakCached(getImage);
```



### 性能

提到js性能就不得不提一下V8,V8是由C++编写的js引擎,尽管js还有其他的引擎(js core等),但是V8是使用率最高的引擎.

我们说js是解释型语言,尽管V8在执行js的时候会进行预编译,并且集成了JIT功能,但是这并不能说js是编译型语言,语言的类型在于语言本身不在于引擎. (由历史性的原因决定的,使得js简单易上手)

作为一门解释型语言,需要进行词法分析,语法分析(AST),解析执行,   

执行过程  先预编译(变量提升) 解析(基线编译器)=>bytecode=>解释执行二进制

再执行过程中会监控代码的执行次数,对少量执行的代码,会进行标记warm,直接保存对应的的二进制.

如果多次执行会标记为hot,会进优化编译器 进行类型假设,但是作为弱类型的语言,类型可能改变那么会去优化

因此使用固定的类型会提高运行速度

关于变量提升,创建内存用以存放变量,在作用域中生成映射,并赋值为undefined,而let不做变量提升,但是会创建映射,不赋值undefined.

```js
for(let i = 0;i<5;i++){//for与for后的{}是两个作用域
	let i = 5;
	console.log(5);
}
```













### 兼容性

现在说的兼容性往往是对ES2015以后版本的兼容,因为ES5这版持续了十几年的时间.而从2015年之后每年都有一个版本发布,所以兼容的问题也一直有,对ESMA规范支持最好的是Node环境. 为解决兼容性我们通常引入babel进行编译,引入polyfill支持新的API这两种吧.





### 展望

ESMAScript每年一版本,每个版本都值得期待,WebAssembly 也提出很久了,TS还是大多数公司的开发必选.





