---
layout: post
title: CSS
date: 2020-12-25
Author: 念书
keyword: css
excerpt: revert,权重,布局,BFC,FFC,GFC,粘性,shape
categories: 
tags: [CSS]
css: style
comments: true
---

​	同样的三驾马车之一CSS, 负责的页面的样式,页面的装潢,可视为人的外表,是一种依存于"文档结构"的语言

### 定义

与JavaScript刚出现时候的不受开发者重视不同,CSS是作为救星出现的,类似于font,center这样的样式标签出现使得HTML页面变得臃肿和非结构化,难以维护,复用性差.也是在95年W3C制定了CSS的相关计划.

从table布局,到div+css(浮动,定位式布局),到现在Flex布局,Grid布局,sticky,Shapes各种布局,css能实现的效果也越来越多,功能越来越强大,很多人都认为CSS比HTML,JavaScript难度高一些.要实现一般功能的页面,主要的几个CSS属性就能够办到,但是要实现华丽的页面就要借助一些少用的属性,或者常用属性的少为人知的特性(比如一个标签实现各种效果系列,CSS揭秘),不过只是属于收集向的,不在本文列出.



#### 选择器 







   [练习选择器的小游戏](https://flukeout.github.io/)

#### 权重

```css
/**** 权重,层叠二字的来源 ****/
/** 首先独一档 !important,最高级别的样式权重,一般用来覆盖不能修改的第三方库样式,覆盖内联样式,因为副作用大不建议常用**/
* {
    color: #ccc !important; /*虽然权重高,但是是样式级别,不是选择器级别*/
}

/** 第二档内联样式,不建议使用修改困难,不能复用,更不建议与!important一起使用(外部无法覆盖) */

<div style="border:1px solid #f60;color:#ccc !important"></div>


/** 第三档正常的权重 id > class,属性选择器[],伪类选择: > 标签,伪元素:: */

/* 根据规范id 具有唯一性,尽管浏览器并没有进行任何限制(写多个CSS也都会应用,连js的document.querySelectorAll也会返回具有相同ID的元素),选择器中id选择器有最高的权重,一般用来加权,或者限制范围*/

#box {
}

/* class选择器是最适合样式的选择器了,复用性好,代码简洁,权重适中,属性选择器相对来说性能不好 */
.box {
}
[name="text"]{
}
.box:first-child { 
    
}
.box:hover {
    
}
/* 元素选择器也不建议使用,尽管也可以减少代码量,但是 CSS选择器从右向左的匹配规则 使得使用元素选择器性能低而且权重低容易被覆盖,通常要其他选择器加权,性能再次变低*/
input {  
}
p::first-line { /*伪元素设置的是元素一部分,或者一种状态,是一种自身不能添加其他选择器的特殊元素*/
    
}
input::placeholder {}

/* 第四档通用选择器  *,性能很低  */

/*需要注意选择器描述的越详细,权重越高,同种选择器数目多的权重高,但是低权重数量再多也比不上高权重(量不改质),权重相同的离着近的(就近原则)生效,而且层级越多性能越差,需要取舍*/
*{} /* 权重很低,相当于默认值 */

.box.box {} 
.box {} /* 多个class比单个class的权重高,即便是相同的class */
#box {} /* 但是即便有再多class也覆盖不了id */

.name {}
[type="text"] /* 属性选择器与class选择器权重相同,遵循就近原则 */
input[type="text"] /* 属性选择如果加上元素就会覆盖掉属性和class */
.name[type="text"] /* 类和属性又会覆盖掉元素属性 */
.name:first-child /* 和class属性组合权重相同 */
.name:hover /*也是,需要注意 */
a:link    {color:blue;} /*超链接的伪类要保持顺序,不然无效*/
a:visited {color:blue;}
a:hover   {color:red;}
a:active  {color:yellow;}

.box .name {}
.box>.inp {}
.name.name {} /* 子类,后代,和两个class的权重相同,也就是 > + ~ 不会增加权重 */
```



#### 通用值

主要介绍几个值 initial inherit unset revert

```html
<style>
    body {
        font-size: 48px;
    }
    .box {
        width: 200px;
        height: 20px;
        text-align: center;
        font-size: 24px;
        border: 1px solid #ccc
    }
    #demo {
        text-align: center;
    }

    #demo2 {
        font-size: initial ;
    }
    #demo3 {
        font-size: inherit ;
    }
    #demo4 {
        font-size: unset ;
    }
    #demo5 {
        font-size: revert;
    }
    .multi {
        all:revert; /* 清除所有外部属性*/
    }
</style>
<h5 id="demo">字体大小</h5>
<div class="box">
	<h5 id="demo1">字体大小</h5>
</div>
<div class="box">
	<h5 id="demo2">字体大小</h5>
</div>
<div class="box">
	<h5 id="demo3">字体大小</h5>
</div>
<div class="box">
	<h5 id="demo4">字体大小</h5>
</div>
<div class="box">
	<h5 id="demo5">字体大小</h5>
</div>

<!-- 字体大小我们通常认为根元素上的字体为16px,最小字体为12px,这是浏览器默认的设置,同时又是用户可改的,所以设置字体大小要加以变通,我们可以看到h5的默认字体大小为0.83em,也就是当前字体大小*0.83,而字体又是可继承的-->

<!-- 第一个h5的字体大小为16*0.83,这是放在body下的常态h5 -->
<!-- 第二个h5的字体大小为24*0.83,这是在字体24px的div中的h5 -->
<!-- 第三个h5的字体大小为16,这是值为initial的h5 -->
<!-- 第四个h5的字体大小为24,这是置为inherit的h5 -->
<!-- 第五个h5的字体大小为24,这是置为unset的h5 -->
<!-- 第六个h5的字体大小为24*0.83,这是值为revert的h5 -->

<!--综上所述,作为可继承的font-size属性,如果不做设置会受到来自父元素的字体大小和元素用户代理设置的影响,设置为initial会回归根元素的字体大小,设置inherit会设置为父元素的字体大小,设置为unset会设置为initial或inherit其中之一,这里是inherit因为font-size是可继承的,换成border就是initial了(只有设置了inherit的h5会有继承自div的边框),设置为unset会还原为不设置font-size的属性即去除font-size属性的影响,可以与富文本配合使用,富文本如果不做隔离展示时经常会被样式覆盖,用reset可以去除外部样式影响而不用给h1,b分别去赋值-->

<!--这让我想起了normalize.css 与 reset css,面对不同浏览器用户代理的差异reset css的作用是去除用户代理的影响,normalise是统一用户代理-->
```

[![hYSPz9.png](https://z3.ax1x.com/2021/08/30/hYSPz9.png)](https://imgtu.com/i/hYSPz9)



#### 单位







然后一般是从盒子模型开始的

[![hGaowR.png](https://z3.ax1x.com/2021/08/29/hGaowR.png)](https://imgtu.com/i/hGaowR)

```html
<style>
/* 盒子模型受box-sizing属性影响,默认值为content-box,还有一个值为border-box也就是以前的IE怪异盒子 */
.box {
	box-sizing: content-box;
    box-sizing: border-box;
}
/* 一般的盒子模型 width = content(设置值) + padding(左右) + border(左右)
   border-box  content = width(设置值) - padding(左右)- border(左右), 两者不同之处 content-box影响的是content宽度不变,去扩展width,border-box是width不变去挤压content宽度,高度也是这样,需要注意的是高度还受margin-bottom的负值影响,负值会减少高度的占位,但不会影响到背景,类似于高度塌陷*/
</style>
<!--还有个值类似的属性background-clip,border-box,padding-box,content-box,默认值是border-box-->

<!--行内元素-->
<!--我们通常说对行内元素设置高度、宽度、垂直方向内外边距等属性，都是无效的,其实这是不准确的,高度,宽度确实无效,margin也没效果,但是padding还是有些许效果的,下边的例子虽然padding不能撑开高度,但是在backgroud属性中生效的,而且border也生效了,相对于块元素来说,行内的padding-box和border-box虚,不能阻挡其他元素侵入,但是存在-->
<style>
    .inline {
        margin-top: 50px;
        margin-left: 20px;
        padding: 20px;
        width: 100px;
        height: 100px;
        background: #f60;
        border: 3px solid #000;
    }
</style>
<div class="inline-box">
    <span class="inline">行内元素1</span>1
    <span class="inline">行内元素2</span>
    <span class="inline">行内元素3</span>
    <div>123</div>
</div>
<!-- 那怎样才能撑起行内元素的高度呢,答案是line-height,我们给上边的inline设置一个行高,在限制一下box的宽度,出现下面这种情况 -->
<style>
    .line-height-box {
        width:  80px;
    }
    .line-height-box .inline{
        line-height: 5;
    }
</style>
<!--可以看到在添加行高后,span的内容区被撑开,下边div不能再侵入span的盒子,但是span并没有因为添加了line-height,产生变化,背景和边框都没改变,即便是因为盒子宽度不够致使换行,也没有使得span变为双倍高,而是切分了背景和表格-->
```
<div class="inline-box">
    <span class="inline">行内元素1</span>1
    <span class="inline">行内元素2</span>
    <span class="inline">行内元素3</span>
    <div>123</div>
</div>
<div class="line-height-box">
    <span class="inline">行内元素1</span>
    <div>123</div>
</div>

line-height,设置行框的高度,即line boxes的高度

盒子的line-height是作为内部line-boxes的最小line-height,每个line-boxes可能由一个或多个inline-boxes组成,而行高则是取这些inline-boxes中line-height中最大的那个,每个内联元素都是一个inline-boxes,包括TextNode,当一行宽度不够换行时,一个inline-boxes被切为两个,第二行的采用第二行的最大高度

#### line-height

+ normal 默认值,取决于用户代理,一般是1.2
+ 无单位的数值 字体大小*数值 = 行高,这是line-height首选的使用方法,可以继承
+ 有单位的数值 px,em  需要注意使用em在继承上会出现问题,会继承计算的结果而不是em值
+ %,根据字体大小计算,继承的也是计算值

vertical-align 提到行高就不得不提一下vertical-align,

vertical-align的默认值是baseline,使元素的基线与所在行的基线(小写x的下边缘)对齐,line-height和基线息息相关,inline-block元素的基线为内部最后一个inline-boxes的基线如果没有则为margin下边缘.这些都会影响到line-boxes的行高,行高并不是只有line-height属性决定. 

 有这么一种现象在一行中我们想让其中一个元素靠下,设置它的margin-top,一开始无效,然后一直加大margin-top,等到某一临界值之后整行元素一起下降.原因就是line-height,一开始元素的line-height的高度不是最高,所以移动基线与行基线对齐,随着margin-top原来越大,元素的基线成为最靠下的那个,掌握了对齐的话语权,自身的基线下移,带动所有的元素下移. 可以采用负值的margin-bottom,提高基线使得元素为了对齐向下移动.

#### vertical-align

+ baseline 元素的基线与行的基线对齐,基线为x的下边缘
+ sub 使元素的基线与行的下标基线对齐, sub元素的默认属性,sub元素另一个属性是font-size:smaller
+ super 使元素与父元素的上标基线对齐,sup元素的默认属性
+ text-top 使元素的顶部与父元素的字体顶部对齐
+ text-bottom 使元素的底部与父元素的字体底部对齐
+ middle 使元素的基线与父元素的基线上x的一般高度对齐
+ length 使元素与父元素基线之上的给定高度对齐
+ % 使元素与父元素基线之上的行高的百分比对齐
+ top 使元素的顶部与整行的顶部对齐
+ bottom 使元素的底部和整行的底部对齐

#### 文本换行

文本换行有语言差异 CJK和 non-CJK,CJK就是汉字和类似汉字的文本

内联元素的换行在遇到float元素时候会产生环绕效果

non-CJK就是其它包含英文,阿拉伯数字等文本,对于non-CJK来说,文本合并空格和换行符,当需要换行时在空格处断行,如果没有空格则不换行,不会断词.如果元素本身没有宽度且与其它元素共处一行,那么这时候元素就会另起一行,如果达到父元素的宽度还没有空格,那么单词溢出到空格处再换行,标点符号处也不会换行 (?可以)

CJK 汉字则不会存在字拆分的问题,所以汉字只要需要任意处可换行

关于内联元素文字的换行有三个相关属性

 + **white-space** 

   	+ white-space控制的是空格处的换行,需要注意的是换行符为回车键而不是'\n'
   	+ normal 默认值,连续的空白符会被合并,换行当做空白处理,必要时会换行,行尾空格删除
   	+ nowrap 合并空格与换行符,不会换行,行尾空格删除
   	+ pre pre标签的默认值 保留空白符和换行符,遇到换行符和br标签换行,否则不会换行,保留行尾空格
   	+ pre-wrap  在pre的基础上,区别在必要时会换行,行尾空白挂起,不占空间
   	+ pre-line  与pre-wrap行为类似,区别在于会合并空白,删除行尾空白
   	+ break-spaces 空格都会保留都存在换行机会,包括在行尾,这些空格会影响高度与换行,可能存在空白独占一行的情况

 + **word-break** 

   	+ break控制的是单词断行,是当一行的最后的单词不能展示完整时是否断行
   	+ normal 默认即不能拆分单词换行
   	+ break-all 可拆分单词进行换行,
   	+ keep-all CJK 文本不可断行,即汉字词句也不能拆分

 + **overflow-wrap** 

    + 原来为word-wrap,同样是单词断行,不同的是wrap控制的是当一行装不下**一个**(长)单词时是否换行,会把长单词拿到新行然后在单词后边断行,而word-break的break-all则是遇到溢出则断行
    + normal 只能在正常的单词断点处换行
    + anywhere 计算最小宽度会考虑分词引入的软换行机会 
    + break-word 计算最小宽度不会考虑分词引入的软换行机会 ,与已经取消的word-break:break-word功能相同

   ps: 最小宽度是指的width:min-content,相对应的是max-content;min指的采用最短断行的宽度,max采用不断行的宽度,同时这两个值受min-width和max-width限制

#### 移动内容盒子

margin,padding,position,transform:translate 四个属性,都有改变元素位置的功能,也都具有%值,拿出来比较一下

+ margin:  %值是根据父元素的宽度来计算的,需要注意即margin-top:20%和margin-left: 20%;这两段距离相等
+ padding: %值同样是根据父元素的宽度来计算的padding:20%;即上下左右的padding相等
+ position: absolute,relative,sticky都是相对于父元素的宽高分别计算,fixed是相对于窗口的宽高计算
+ transform:translate();是相对于自身的宽高计算的
+ ps: 在元素没有设置宽度的时候margin会影响宽度,fixed.absolute会包裹内容,其他保持宽度(出现滚动条)

```css
.box {
	position: absolute;
	top: 0;
	left: 0;
	bottom: 0;
	right: 0;
	margin: auto;
}
/* 当元素有宽高时,这段代码使得元素绝对居中,当没有宽高时,修改margin会影响到宽高*/
```



display属性分为内部,外部;外部决定着元素参与流式布局的方式,内部决定着子元素的布局方式,目前有两种方式表示一种是legacy(遗留)关键字 例如inline-block,inline-flex;新的语法采用两个关键字two-value: inline flow-root,inline flex,不过这种语法目前只有Firefox支持,chrome不支持

+ **block** 使元素生成块元素框,参与正常流布局,内部值为flow;例如div,ul
  + list-item li     list-style-type list-style-position
+ **inline** 使元素生成内联元素框,内部值为flow
+ **run-in** 已经不被支持了
+ **flow** 元素内部使用流布局
+ **flow-root** 生成一个块元素框(BFC)
+ **table** 表格的默认
  	+ table-row-group tbody元素的display用户代理
  	+ table-head-group thead元素的display用户代理
  	+ table-footer-group tfoot元素的display用户代理
  	+ table-row tr的
  	+ table-cell td的
  	+ table-column-group colgroup
  	+ table-column col
  	+ table-caption caption
+ **ruby**  ruby元素的默认
  + ruby-base rb
  + ruby-text rt
+ **flex** 内部元素flexbox 模型布局
+ **grid** 内部元素根据网格模型布局
+ **content ** 元素本身不产生盒子,不显示元素,但是显示子代
+ **none** 不显示元素,不显示子代,不能够通过屏幕访问
+ **inline-table** ,**inline-flex**  **inline-grid**  把外部为block的改为inline 
+ **inline-block** 像一个替换元素(img), inline flow-root

由display引出的几种布局 主要为flow,IFC,BFC,FFC,GFC

+ **Flow**  流式布局,正常流中任何框都是格式化上下文的一部分,可以是块,亦可以是内联,块级框参与块格式化上下文,内联框参与内联格式上下文

+ **table-layout**

+ **overflow** 溢出,当内容填充满包含框,继续以可见的方式溢出,在框外显示,控制溢出的属性overflow默认值是visible

+ **out of flow ** 脱离文档流

  + float
  + position:absolute
  + position:fixed
  + root

+ **direction,unicode-bidi** 文字方向(双向算法),建议使用H5的dbi和dbo标签,语义性好一些

  + direction:ltr 默认 左对齐 不会改变文字的排列顺序,如果行结尾是标点,标点在行右边
  + direction:rtl 右对齐如果行的结尾是标点,标点在行右边,对于内联元素宽度为包裹,所以现象不明显
  + unicode-bidi: bidi-override 与direction:rtl配合文字书写方向改变从右向左
  + unicode-bidi: plaintext; 不考虑父元素不考虑direction(使得لرجل القوي إيان这种语言)

  <textarea readonly>لرجل القوي إيان</textarea>

+ **writing-mode** 布局方向

  + horizontal-tb
  + vertical-rl

+ **IFC** 块级元素内仅包含内联级别元素

  + 内联格式化上下文中,从包含块的顶端开始一个接一个的水平布置框,这些框以不同的方式垂直对齐.水平方向的margin,padding,border所占的空间都会被考虑在内
  + 每一行的宽度与包含块和浮动元素决定,左边缘和右边缘都和包含块的左边缘和右边缘重合,如果有浮动元素则元素的左边缘与左浮动元素的右边缘重合,右边缘与右浮动的左边缘重合,当一个内联元素的宽度超过line-box的宽度的时候会分隔为两个inline-boxes,如果不能分隔则会溢出
  + 每一行的高度则由行高最大的那个内联元素决定
  + 可以用text-align,line-height,vertical-align控制元素的居中和对齐

+ **columns** 多列布局

  + IFC布局中基本单位是行框,columns多列布局中基本单位是列框
  + column-count,内容分为几列,但这是可变的,受内容,列宽和其它属性影响,可能变少,也能变多
  + column-width ,每列宽度,这也是可变的,受盒子宽度影响
  + column-gap 列间距
  + column-rule 列分割线
  + column-span 对块元素生效,使元素独占一行,上下内容分别成列
  + break-inside: avoid 禁止分页的时候拆分元素(保证元素的整体性)
  + break-after: column 在元素后分页
  + break-before:column 在元素前分页

+ **BFC** 独立的渲染区域,内部布局不会影响到外部元素

  + 块级格式化上下文中,从块的顶端开始,垂直的布置框,垂直方向的距离由margin决定,垂直间距折叠(外间距合并现象)
  + 每个框的左边缘都接触到包含块的左边缘
  + 根元素,浮动元素,绝对定位元素,inline-blocks,overflow值不为visible的元素,flex元素都可以形成BFC,但是这些属性都有各自的作用,单纯用来实现BFC相当于增加了副作用,所以现在有了 flow-root专门形成BFC
  + 用于解决高度塌陷,外间距合并现象

+ **FFC**  Flex 格式上下文 弹性布局   [练习Flex布局的小游戏](http://flexboxfroggy.com/)

  + 

+ **GFC**  栅格格式上下文  [练习Grid布局的小游戏](http://cssgridgarden.com/)

  + 